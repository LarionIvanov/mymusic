<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ú–æ—è –º—É–∑—ã–∫–∞</title>
  <style>
    body {
      font-family: sans-serif;
      background: white;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }

    h1 {
      margin-bottom: 1rem;
    }

    #upload-section {
      margin-bottom: 2rem;
      border: 2px dashed #ccc;
      padding: 1.5rem;
      border-radius: 10px;
      width: 320px;
      text-align: center;
    }

    #audioList {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 320px;
    }

    .track {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      border: 1px solid #ddd;
      padding: 1rem;
      border-radius: 8px;
      background: #fafafa;
      cursor: grab;
    }

    .drag-over {
      border: 2px dashed #007aff;
      background: #eef6ff;
    }

    audio {
      width: 100%;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <h1>üéµ –ú–æ—è –º—É–∑—ã–∫–∞</h1>

  <div id="upload-section">
    <input type="file" id="fileInput" accept="audio/*" />
    <button id="uploadButton">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç—Ä–µ–∫</button>
    <p id="status"></p>
  </div>

  <div id="audioList"></div>

  <script type="module">
  import { Client, Storage, Account, ID, Databases } from "https://cdn.jsdelivr.net/npm/appwrite@13.0.0/+esm";

  // === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Appwrite ===
  const client = new Client()
    .setEndpoint('https://cloud.appwrite.io/v1')
    .setProject('68edff2c00028e4b809b');

  const account = new Account(client);
  const storage = new Storage(client);
  const databases = new Databases(client);

  const bucketId = '68edff670001c6096f18';
  const databaseId = 'main';
  const tableId = 'tracks_order'; // –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã

  const fileInput = document.getElementById('fileInput');
  const uploadButton = document.getElementById('uploadButton');
  const audioList = document.getElementById('audioList');
  const statusText = document.getElementById('status');

  // === –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è (–∞–Ω–æ–Ω–∏–º–Ω–∞—è —Å–µ—Å—Å–∏—è) ===
  async function ensureAnonymousSession() {
    try {
      await account.get();
    } catch {
      await account.createAnonymousSession();
    }
  }

  // === –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ ===
  async function getSavedOrder() {
    try {
      const res = await databases.listDocuments(databaseId, tableId);
      if (res.documents.length > 0) {
        const orderData = res.documents[0].order;
        return JSON.parse(orderData);
      }
    } catch (err) {
      console.warn("–ü–æ—Ä—è–¥–æ–∫ —Ç—Ä–µ–∫–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω:", err);
    }
    return null;
  }

  // === –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ ===
  async function saveOrder(orderArray) {
    try {
      const existing = await databases.listDocuments(databaseId, tableId);
      const json = JSON.stringify(orderArray);

      if (existing.documents.length > 0) {
        const docId = existing.documents[0].$id;
        await databases.updateDocument(databaseId, tableId, docId, { order: json });
      } else {
        await databases.createDocument(databaseId, tableId, ID.unique(), { order: json });
      }
    } catch (err) {
      console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞:", err);
    }
  }

  // === –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–æ–≤ ===
  async function loadTracks() {
    try {
      const result = await storage.listFiles(bucketId);
      const savedOrder = await getSavedOrder();

      let files = result.files;
      if (savedOrder) {
        files.sort((a, b) => savedOrder.indexOf(a.$id) - savedOrder.indexOf(b.$id));
      }

      audioList.innerHTML = '';
      for (const file of files) {
        const fileUrl = `https://cloud.appwrite.io/v1/storage/buckets/${bucketId}/files/${file.$id}/view?project=68edff2c00028e4b809b`;
        const trackDiv = document.createElement('div');
        trackDiv.classList.add('track');
        trackDiv.draggable = true;
        trackDiv.dataset.id = file.$id;

        trackDiv.innerHTML = `
          <strong>${file.name}</strong>
          <audio controls src="${fileUrl}"></audio>
        `;

        audioList.appendChild(trackDiv);
      }

      enableDragAndDrop();
      enableAutoPlay();
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤:', error);
      statusText.textContent = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ø–∏—Å–∫–∞ —Ç—Ä–µ–∫–æ–≤!';
    }
  }

  // === –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–æ–≤–æ–≥–æ —Ç—Ä–µ–∫–∞ ===
  uploadButton.addEventListener('click', async () => {
    const file = fileInput.files[0];
    if (!file) {
      statusText.textContent = "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª!";
      return;
    }

    statusText.textContent = "‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...";
    try {
      await storage.createFile(bucketId, ID.unique(), file);
      statusText.textContent = "‚úÖ –¢—Ä–µ–∫ –∑–∞–≥—Ä—É–∂–µ–Ω!";
      fileInput.value = "";
      await loadTracks();
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞:', error);
      statusText.textContent = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ!";
    }
  });

  // === Drag and Drop ===
  function enableDragAndDrop() {
    let dragged;

    audioList.querySelectorAll('.track').forEach(track => {
      track.addEventListener('dragstart', e => {
        dragged = track;
        track.style.opacity = 0.5;
      });

      track.addEventListener('dragend', e => {
        track.style.opacity = '';
      });

      track.addEventListener('dragover', e => {
        e.preventDefault();
        track.classList.add('drag-over');
      });

      track.addEventListener('dragleave', () => {
        track.classList.remove('drag-over');
      });

      track.addEventListener('drop', e => {
        e.preventDefault();
        track.classList.remove('drag-over');
        if (dragged && dragged !== track) {
          const tracks = [...audioList.children];
          const draggedIndex = tracks.indexOf(dragged);
          const targetIndex = tracks.indexOf(track);

          if (draggedIndex < targetIndex) {
            audioList.insertBefore(dragged, track.nextSibling);
          } else {
            audioList.insertBefore(dragged, track);
          }

          const newOrder = [...audioList.children].map(div => div.dataset.id);
          saveOrder(newOrder);
        }
      });
    });
  }

  // === –ê–≤—Ç–æ–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ ===
  function enableAutoPlay() {
    const audios = document.querySelectorAll("audio");

    audios.forEach((audio, index) => {
      audio.addEventListener("ended", () => {
        const nextAudio = audios[index + 1];
        if (nextAudio) {
          nextAudio.play();
        } else {
          const firstAudio = audios[0];
          if (firstAudio) firstAudio.play();
        }
      });
    });
  }

  // === –ó–∞–ø—É—Å–∫ ===
  (async () => {
    await ensureAnonymousSession();
    await loadTracks();
  })();

  </script>
</body>
</html>
